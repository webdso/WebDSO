<!-- Initial version of this HTML code was found at gnuplot, "help set term
     canvas" command. JS file js/cos.js was generated by gnuplot with:
       set term canvas name 'cs'; set output 'js/cos.js'; plot cos(x)  --> 
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
  <title>DSO demo</title>
  <link rel="shortcut icon" type="image/png" href="generator-16x16.png"/>
  <script src="js/gnuplot/canvastext.js"></script>
  <!--script src="js/gnuplot/canvasmath.js"></script-->
  <script src="js/gnuplot/gnuplot_common.js"></script>
  <!--script src="js/gnuplot/gnuplot_dashedlines.js"></script-->
  <script src="js/gnuplot/gnuplot_mouse.js"></script>
  <!--link rel="stylesheet" type="text/css" href="js/gnuplot/gnuplot_mouse.css" /-->
  <!--link rel="stylesheet" type="text/css" href="normalize.css" /-->

  <style>
    body {
      background: #FFFFFF;
      font-family: Tahoma,arial,sans-serif;
      font-size: 14px;
      font-weight: normal;
    }
    input {
      background: #FFFFFF;
      padding: 3px;
      margin: 1px;
    }
    select {
      background: #FFFFFF;		/* This changes selectors' look */
      margin-top: 2px;
      padding: 2px;
    }
    
    /* Button styling created by https://www.bestcssbuttongenerator.com/#/1
     * with some local tweaks, original code kept separately. 
     */
    button {
      width: 92px;
      -moz-box-shadow: 0px 0px 0px 2px #ffffff;
      -webkit-box-shadow: 0px 0px 0px 2px #ffffff;
      box-shadow: 0px 0px 0px 2px #ffffff;
      background:-webkit-gradient(linear, left top, left bottom, color-stop(0.05, #ededed), color-stop(1, #dfdfdf));
      background:-moz-linear-gradient(top, #ededed 5%, #dfdfdf 100%);
      background:-webkit-linear-gradient(top, #ededed 5%, #dfdfdf 100%);
      background:-o-linear-gradient(top, #ededed 5%, #dfdfdf 100%);
      background:-ms-linear-gradient(top, #ededed 5%, #dfdfdf 100%);
      background:linear-gradient(to bottom, #ededed 5%, #dfdfdf 100%);
      background-color:#ededed;
      -moz-border-radius:8px;
      -webkit-border-radius:8px;
      border-radius:8px;
      border:1px solid #909090;
      cursor:pointer;
      color:#000000;
      text-decoration:none;
      text-shadow:0px 1px 0px #ffffff;
    }
    button:hover {
	background:-webkit-gradient(linear, left top, left bottom, color-stop(0.05, #dfdfdf), color-stop(1, #ededed));
	background:-moz-linear-gradient(top, #dfdfdf 5%, #ededed 100%);
	background:-webkit-linear-gradient(top, #dfdfdf 5%, #ededed 100%);
	background:-o-linear-gradient(top, #dfdfdf 5%, #ededed 100%);
	background:-ms-linear-gradient(top, #dfdfdf 5%, #ededed 100%);
	background:linear-gradient(to bottom, #dfdfdf 5%, #ededed 100%);
	background-color:#dfdfdf;   
    }
    button:active {
	position:relative;
	top:1px;
    }
    button:disabled {
      color:#808080;
      cursor: not-allowed;
    }
    
  </style>
</head>

<!-- JS stuff goes here -->
<script type="text/javascript">
//  gnuplot.hypertext_list = [];
  // Mouse control subroutines are supplied by Gnuplot and live in 
  // gnuplot_mouse.js. All of them call "gnuplot_canvas()" to redraw the plot. 
  // However, "name 'cs'" parameter of "plot" command (see dsoPlotData.pl) 
  // generated canvas and drawing function under "cs" name. To make mouse control
  // work we invented gnuplot_canvas() wrapper which simply calls cs().
  function gnuplot_canvas() {
    cs();
  }

  var dataLoopId;			// Data gathering control
  var dataLoopRun = 1;			// Data gathering status: 1 - running
  var lastScript = null;		// Last loaded JS script

  var srcCtl = {			// Data source selection object
    dsoIP: '',				// DSO IP address
    dataSrc: null,			// Signal source selector,see "init()"
    dataIp: null,			// Device IP address,see "init()"
    checkIP: function() {
      statMsg("");			// Reset error message first
      if (this.dataSrc.value == "dso") {
	if (! /^\d+\.\d+\.\d+\.\d+$/.test(this.dataIp.value)) {  // Bad IP?
	  this.dataSrc.selectedIndex = "0";		// Reset back to imitator
	  document.title = "DSO demo";
	  return(goodNumber('NaN',0,0,"Incorrect IP addr: "+this.dataIp.value,
			    this.dataIp));
	}
	document.title = "DSO @ "+this.dataIp.value;	// Update page title
	this.dsoIP = this.dataIp.value;
	this.dataSrc.selectedIndex = 1;			// Select DSO if IP addr.OK
      } else {				// ..Imitator
        this.dsoIP = '';		// Just reset device's IP
        document.title = "DSO demo";	// And page title
      }
    },
    init: function() {
      this.dataSrc = document.getElementById("dataSrcId");
      this.dataIp = document.getElementById("dataIpId");
      this.dataSrc.selectedIndex = "0";
      this.dataIp.value = this.dsoIP;
    }
  };
  
  var dataRefresh = {			// Refresh plot control
    delay: 500,				// Default wait time between refreshes
    init: function() {
      document.getElementById("refreshDelayId").value = this.delay;
    },
    set: function(newDelay) {
      if (! goodNumber(newDelay,0,99999,"Invalid delay value: "+newDelay,
		       document.getElementById("refreshDelayId"))) return;
      this.delay = newDelay;
    }
  };
  
  var plotSize = {
    h: 600,				// Default plot height
    w: 800,				// Default plot width
    plotW: null,			// Plot width entry box,see "init()"
    plotH: null,
    cs: null,				// Plot canvas,see "init()"
    init: function() {
      this.plotW = document.getElementById("plotWId");
      this.plotH = document.getElementById("plotHId");
      this.plotW.value = this.w; this.plotH.value = this.h;
      this.cs = document.getElementById("cs");
      this.cs.addEventListener("mousedown",this.mouseDn,true);
      this.cs.addEventListener("mousemove",this.passEvent,false);  // Pass these two
      this.cs.addEventListener("mouseleave",this.passEvent,false); // events to underlaying div
      this.adjustPLotArea();
    },
    adjustPLotArea: function() {	// Adjust crosshairs area to reflect canvas
      var plotArea = document.getElementById("plotAreaId");	// Crosshairs area
      plotArea.style.top = (this.cs.offsetTop+10.0)+"px";     	// Adjust size and 
      plotArea.style.left = (this.cs.offsetLeft+62.0)+"px";   	// position to fit
      plotArea.style.height = (this.cs.offsetHeight-45)+"px";	// plot area. 
      plotArea.style.width = (this.cs.offsetWidth-88)+"px"; 
    },					// -- adjustPLotArea --
    passEvent: function(eve) {		// Clone mouse event and send to crosshairs div
      var crossArea = document.getElementById("plotAreaId");
      var ev = new Event(eve.type);	// Createevent of the source type
      ev.pageX = eve.pageX; ev.pageY = eve.pageY;	// Copy mouse coord's
      ev.clientX = eve.clientX; ev.clientY = eve.clientY;
      crossArea.dispatchEvent(ev);	// Send event to crosshairs
    },
    mouseDn: function(eve) {		// Ignore mouse clicks if plot is running
      if (dataLoopRun) eve.stopImmediatePropagation();
    },
    mkBorder: function() {		// Draw/cleanup border over inactive plot
      this.cs.style.border = dataLoopRun ? 'none' : '1px dotted grey';
    },
    setW: function(newW) {
      if (! goodNumber(newW,100,1600,"Invalid width: "+newW,
		       this.plotW)) return;
      this.w = Number(newW).toFixed();	// Width could be given as 1E+3
      this.cs.width = this.w;		// Resize canvas
      this.mkBorder();
      this.adjustPLotArea();
    },
    setH: function(newH) {
      if (! goodNumber(newH,50,1000,"Invalid height: "+newH,
		       this.plotH)) return;
      this.h = Number(newH).toFixed(); 	// Height could be given as 1E+3
      this.cs.height = this.h;		// Resize canvas
      this.mkBorder();
      this.adjustPLotArea();
    }    
  }
  
  /* 
   * crossHairs - display fine crossed lines over mouse tip when the mouse is 
   * 		  over designated area.
   *
   * Methods: init(areaId,horizId,vertId) - initialize crosshairs. "init()" method
   *		expects HTML id's of the target area and two "<div>"s representing 
   *		horizontal and vertical lines. See HTML elements with "cs", 
   *		"hAxId" and "vAxId" id's somewhere in the HTML code. "init()" 
   *		adds "mousemove" and "mouseleave" events listeners to "areaId" 
   *		target area. After init() call, a browser will draw crosshairs 
   *		whenever mouse enters areaId area;
   *	      showCross(mouseEvent) - display crosshairs at coordinates given
   *		with "mouseEvent" event. Coordinates have to be within target
   *		area. Usually there is no need to call this method;
   *	      hideCross() - hide crosshairs. They re-appears when mouse moves within
   *		the target area. This method and event handler are optional since
   *		init() configures showCross() handler to process mouse events and
   *		the former constantly checks current mouse position and hides the 
   *		cross when the mouse gets outside the target area.
   *
   * NOTE: 1. "hAxId" and "vAxId" lines are 1x1 px "<div>"s. Only left (or top)
   *	      borders must be visible, other three must be "none" (but one might
   *	      experiment with thicker "<div>"s, borders, colors, etc.. "z-index" 
   *	      of both "div"s must be -1 to put the axis "under" target area - 
   *	      otherwise the thing won't work!
   *	   2. showCross(event) function works as event handler and therefore keyword
   *	      "this" in the body of the function refers to passed event and not 
   *	      enclosing "crossHairs" object. To use "this" in a normal manner,
   *	      showCross(event) handler must be attached to mousemove event with
   *	      "bind()" call (see init() below). If some browser doesn't support
   *	      "bind()", remove ".bind(crossHairs)" clause in addEventListener() 
   *	      calls in init() AND replace "this." with "crossHairs." in showCross().
   */
  var crossHairs = {			// The stuff to display csosshair on canvas
    x: 0,				// Mouse current position
    y: 0,
    target: null,			// Target (crosshair'ed) object
    hAx: null,				// Horizontal axis id
    vAx: null,				// Vertical axis id
    init: function(targetId,horizId,vertId) {
      this.target = document.getElementById(targetId);
      this.hAx = document.getElementById(horizId);
      this.vAx = document.getElementById(vertId);
      this.target.addEventListener("mousemove",this.showCross.bind(crossHairs),true);
      this.target.addEventListener("mouseleave",this.hideCross.bind(crossHairs),true);
   },					// -- init --
    showCross: function(e) {		// Get coord's and show crosshairs
      this.getMousePos(e);		// Store mouse pos.in (x,y)
      if (this.inArea(e)) this.drawHairs()
      else this.hideCross();
    },					// -- showCross --
    inArea: function(e) {		// Returns true if current pos.within event area
      if ((this.x > e.target.offsetLeft) &&
          (this.x < e.target.offsetWidth + e.target.offsetLeft) &&
          (this.y > e.target.offsetTop) &&
          (this.y < e.target.offsetHeight + e.target.offsetTop)) return true;
      return false;
    },
    hideCross: function() {		// Hide crosshairs
      this.hAx.style.visibility="hidden";
      this.vAx.style.visibility="hidden";
    },					// -- hideCross --
    getMousePos: function(e) {
      var ev = e || window.event; 	//Moz || IE
      if (ev.pageX) { 			//Moz
        this.x = ev.pageX + window.pageXOffset;
        this.y = ev.pageY + window.pageYOffset;
      } else if (ev.clientX) { 		//IE
        this.x = ev.clientX + document.body.scrollLeft;
        this.y = ev.clientY + document.body.scrollTop;
      }
//      console.log("Mouse: "+this.x+", "+this.y);
    },					// -- getMousePos --
    drawHairs: function() {		// Display crosshairs at (x,y)
      this.vAx.style.left = this.x+'px';
      this.vAx.style.top = this.target.offsetTop + 'px';
      this.vAx.style.height = this.target.offsetHeight + 'px';
      this.vAx.style.visibility="visible";

      this.hAx.style.left = this.target.offsetLeft+'px';
      this.hAx.style.top = this.y + 'px';
      this.hAx.style.width = this.target.offsetWidth + 'px';
      this.hAx.style.visibility="visible";
    }					// -- drawHairs --
  }					// --- crossHairs ---
  
  var dsoData = {			// DSO control data and methods
    wavPoints: 250,			// Iintial no.points
    timRange: 1,			// Initial time range,msec
    chanCols: ["E69F00","56B4E9",	// RGB channels colors
               "9400D3","009E73"],
    defCol: "4f4f4f",			// Default color: ext.triggger,etc. 
    chanSel: null,			// Channel picklist Id
    couplig: 'AC',			// Channel input
    chanRang: null,			// Channel vert.range
    chanScal: null,			// Channel vert.scal (linked with range)
    plotOrig: null,			// Plot start selector
    trig: 1,				// Trigger channel or ext.trigger
    stat: null,				// DSO status,see dsoPlotData.pl DsoStatus()
    init: function() {
      document.getElementById("wavPointsId").value = this.wavPoints;
      document.getElementById("timRangeId").value = this.timRange;
      document.getElementById("timRangeSelId").value = "1E-3";
      this.plotOrig = document.getElementById("plotOrigSelId");
      this.chanSel = document.getElementById("chanSelId");
      this.chanSel.selectedIndex = "0";			  // Select 1st channel
      this.shoCnColor('chanColorId',this.chanSel.value);  // Display chan.color
      this.shoCnColor('trigColorId',this.trig);  	  // Color trigger label
      this.coupling = document.getElementById("chanCoupId").value;
      document.getElementById("trigId").selectedIndex = "0"; // Trig.by 1st chan.
    },
    chanSet: function(chanNo) {
      runCmd("statReq","cn",chanNo);
    },					// -- chanSet --
    coupSet: function(coup) {		// Set channel's coupling
      this.coupling = coup
      runCmd("Coupling","val",coup,"cn",this.chanSel.value);
    },					// -- coupSet --
    pointsSet: function(newPts) {
      if (! goodNumber(newPts,100,10000,"Invalid no.points in the plot: "+newPts,
		       document.getElementById("wavPointsId"))) return;
      this.wavPoints = newPts;
    },
    timRefSet: function(orig) {		// Set time reference with corr.
      if ((orig == "LEFT") ||
          (orig == "CENT") ||
          (orig == "RIGH")) { runCmd("TimRef",'val',orig); }
      else { statMsg('"Plot start" - Incorrect option "'+orig+'"'); }
    },
    timRangeSet: function(val,unit) {	// Set time range (:TIM:RANG)
      this.timRange = val * unit;
      // FIXME: Verify time range, use goodNumber() function
// alert("timRangeSet: "+val+","+unit+","+this.timRange);
      runCmd("TimRange",'val',this.timRange);      
    },
    vRangeSet: function(vRang,chanNo) {	// Set vertical range (:CHANn:RANG V)
      // FIXME: Verify vert.range, use goodNumber() function
      this.chanRang = vRang;
      runCmd("VertRange",'val',this.chanRang,"cn",chanNo);
    },
    vScaleSet: function(vScal,chanNo) {	// Set vertical range (:CHANn:SCAL Vdiv)
      // FIXME: Verify vert.scale, use goodNumber() function
      this.chanScal = vScal;
      runCmd("VertScale",'val',this.chanScal,"cn",chanNo);
    },
    shoCnColor: function(areaId,chanNo) {  // Color passed HTML area to chan.color
      var color;
      if ((chanNo > 0) && 
          (chanNo <= this.chanCols.length)) { color = this.chanCols[chanNo-1]; }
      else { color = this.defCol; }
      document.getElementById(areaId).style.color = '#'+color;
    },					// --- shoCnColor ---
    trigSet: function(trgChan) {	// Set trigger channel
      this.trig = trgChan;		// Save desired ch#
      runCmd("TrigCh","val",this.trig,"cn",this.chanSel.value);
    },					// --- trigSet ---
    showStat: function(stat) {		// Receive and show DSO parameters
      var tNum;				// Intermediate number
      this.stat = stat;			// Save status data
					// Set chan.selector and color code
      this.chanSel.selectedIndex = this.stat.wavSour.replace(/CHAN/,'') - 1;
      this.shoCnColor('chanColorId',this.chanSel.value);
      this.coupling = this.stat.chanCoup;
      document.getElementById("chanCoupId").value = this.coupling;
      this.plotOrig.value = this.stat.timRef;		// Set "plot start"
      this.wavPoints = Number(this.stat.wavPoin);	// Set wave pts value&picklist
      document.getElementById("wavPointsId").value = this.wavPoints;
      tNum = this.stat.timRang * this.stat.timeScale;	// Horiz.time w/o units
      document.getElementById("timRangeId").value = (tNum*1000).toFixed(0) / 1000;
      document.getElementById("timRangeSelId").value = (this.stat.timeUnit == 'nsec')? "1E-9" :
						       (this.stat.timeUnit == 'usec')? "1E-6" :
						       (this.stat.timeUnit == 'msec')? "1E-3" : "1";
      this.trig = (this.stat.trigEdgeSour === "EXT") ? "E" :
						       this.stat.trigEdgeSour.replace(/CHAN/,'');
      document.getElementById("trigId").value = this.trig;
      this.shoCnColor('trigColorId',this.trig);
      this.chanRang = this.stat.chanRang;
      document.getElementById("chanRangId").value = parseFloat(this.chanRang).toFixed(2);
      this.chanScal = this.stat.chanScal;
      document.getElementById("chanScalId").value = parseFloat(this.chanScal).toFixed(2);
      statMsg(this.stat.errMsg);		// Display error or clear err.area
      this.stat.wasSeen = (new Date()).toLocaleString();	// Mark data as processed
    }					// --- showStat() ---
  }					// --- /dsoData ---
 
 
  /*
   * initPage - initialize HTML element on this page when the page loads.
   */
  function initPage() {
    srcCtl.init();
    plotSize.init();
    dsoData.init();
    crossHairs.init('plotAreaId','hAxId','vAxId');
    dataRefresh.init();
//    gnuplot.init(); Don't need it for canvas generated with "name canvNam"
  }					// --- initPage ---
  
  /*
   * loadJS - load JS file on-the-fly and run it as it gets loaded. 
   * See https://stackoverflow.com/questions/14521108/dynamically-load-js-inside-js
   * and https://stackoverflow.com/questions/950087/how-do-i-include-a-javascript-file-in-another-javascript-file
   * Parameters:
   *   - url - URL of the file to load;
   *   - code2Run - the code to run when the file gets loaded, something like
   *                "function() { cs(); }" (cs() is the function defined in
   *		     the target code).
   * NB: 1. Local variable "locationInDOM" determines DOM node where we insert 
   *	    the script we load, should be like "document.head" or more reliably
   *        (FaceBook approved!) "document.getElementsByTagName('script')[0]".
   *     2. When original version of this function was called in a loop, it
   *        just created endless chain of new "script" tags. To cope this tags
   *        removing code was added, the code stores last loaded URL (w/o
   *        parameters) in global variable "lastScript" and removes this node 
   *	    if the variable is defined and url was not changed. This version  
   *	    doesn't create endless chain of script tags of the same url, but it  
   *	    chains scripts of the same URL if one of them gets differ - be 
   *        warned and test it then fix the code. 
   *	 3. This version slowly leaks memory when loading even an empty script,
   *        but garbage collector does handle it.
   */
  function loadJS(url,code2Run){
    
    if (lastScript && lastScript.url == url.replace(/\?.*$/,'')) { // If the same script was loaded before?
      lastScript.parentNode.removeChild(lastScript);
    }
    var locationInDOM = document.getElementsByTagName('script')[0];
    
    var scriptTag = document.createElement('script');	// Create <script> tag
    scriptTag.src = url;		// Start loading target script

    scriptTag.onload = code2Run;	// Run script when loaded
    scriptTag.onreadystatechange = code2Run;
    
    lastScript = locationInDOM.parentNode.insertBefore(scriptTag,locationInDOM);
    lastScript.url = url.replace(/\?.*$/,'');	// Save script URL w/o params
  }					// --- loadJS ---
   

  /* 
   * Initiate data plot script generation on the server side, load plot script
   * the server returns, run it and re-schedule the next run. This function just
   * calls "loadJS()" and passes it a callback and hence could be replaced by
   * direct call of "loadJS()".
   *
   * NOTE: dsoData.shoCnColor() call here is just to color selected channel 
   *	   indicator next to channel selector. This call is needed to workaround 
   *	   the bug in old Firefox browser in the office: it sets picklist value
   *	   when hovering over options list - this is convenient(!) but does not
   *	   update color indicator (which is confusing). This call is not needed
   *       for modern browsers and could be witdrawn.
   */
  function dataLoop() {
    loadJS("dsoPlotData.pl?ip="+srcCtl.dsoIP+ 	// Returns JS code to plot data
			  "&mode=Plot&w="+plotSize.w+"&h="+plotSize.h+
			  "&cn="+dsoData.chanSel.value+
			  "&color="+dsoData.chanCols[dsoData.chanSel.value-1]+
			  "&wP="+dsoData.wavPoints,
           function() { 		// Run it when desired code loaded
             clearCanvas();		// Cleanup current plot
             statMsg("");		// Cleanup message area
             dsoData.shoCnColor('chanColorId',dsoData.chanSel.value);
             cs(); 			// Draw new one
             if (dataLoopRun) dataLoopId = setTimeout(dataLoop,dataRefresh.delay);
           });
  }					// --- dataLoop() ---
  
  
  /*
   * switchDataLoop - stop or start periodic ("single" argument is 0) or single 
   * ("single" argument is 1) data gathering, update status flag and button label.
   */
  function switchDataLoop(single) {
    if (dataLoopRun) {			// Is data gathering active?
      clearTimeout(dataLoopId);		// Stop by resetting next loop timeout
      dataLoopRun = 0;			// Reset activity flag
    } else {				// .. Stopped
      if (single) statMsg("Single run...");
      dataLoop();			// Run it
      dataLoopRun = single? 0 : 1;	// If single run - don't keep running
    }
    document.getElementById("stopDtLoopId").innerHTML = dataLoopRun ? "Stop" : "Run";
    document.getElementById("singleDtLoopId").disabled = dataLoopRun ? 1 : 0;
    document.getElementById("gnuplot_textzoom_icon").disabled = dataLoopRun ? 1 : 0;
    document.getElementById("gnuplot_rezoom_icon").disabled = dataLoopRun ? 1 : 0;
    document.getElementById("gnuplot_unzoom_icon").disabled = dataLoopRun ? 1 : 0;
    plotSize.cs.style.cursor = dataLoopRun ?  "progress" : "crosshair";
  }					// --- switchDataLoop() ---
 
 
  /*
   * runCmd - send to the instrument one of predefined modes with two optional
   *	      "&parName=param" pairs (not very neat, use "arguments" function),
   *	      If in return we get "cs()" function (that is,server ran Gnuplot),
   *	      then run it, if we get dsoStatus() function, then parse it and 
   *	      update HTML page areas.
   */
  function runCmd(mode,parName,param,parName1,param1) {
    param = (typeof(parName) !== 'undefined')? "&"+parName+"=" + param : "";
    param += (typeof(parName1) !== 'undefined')? "&"+parName1+"=" + param1 : "";
    statMsg("Running...");
    loadJS("dsoPlotData.pl?ip="+srcCtl.dsoIP+ 	// Run "mode" get reply as
			  "&mode="+mode+param,	// JS code in cs() function
           function() { 		// Run reply when it gets loaded
             if (typeof(cs) === 'function') {	// Server returns cs() on error
               cs(); 			// Err.msg is wrapped in cs() function
               cs = undefined;		// To prevent extra cs() run 
             }
             if (typeof(dsoStatus) === 'function') { // We got dsoStatus() func.?
               dsoData.showStat(dsoStatus());	     // Then run it
               dsoStatus = undefined;	// Undefine dsoStatus() - prevent extra runs
             }
           });
  }					// --- runCmd() ---
  
  
  /*
   * isEnterKey -- returns true if <Enter> was pressed, false otherwise.
   */
  function isEnterKey(event) {
    return(event.keyCode == 13);
  }					// --- isEnterKey ---

  
  /*
   * goodNumber -- check if argument is a number within passed limits,
   *		   if not - display passed message and put focus to the given
   *		   element. Returns true or false.
   */
  function goodNumber(val,min,max,msg,focusTo) {
    statMsg('');			// Reset status message
    if ((Number.isInteger(Number(val))) && 
        ((val >= min) && (val <= max))) return(true);
    statMsg(msg);
    focusTo.focus();			// FIXME: Doesn't work for text fields(!)
    return(false);
  }
 
 
  /*
   * clearCanvas - before next plot cleanup plot area, remove the border.
   */
  function clearCanvas() {
    var c = plotSize.cs;
    c.style.border = 'none';
    c.getContext("2d").clearRect(0,0,c.clientWidth,c.clientHeight);
  }					// --- clearCanvas() ---
  
  
  /*
   * statMsg - put a message to the status area with hardcoded id.
   */
  function statMsg(msg) {
    document.getElementById('statAreaId').innerHTML = msg;
  }					// --- statMsg() ---

  
  /*
   * gnuplotButn - toggle gnuplot canvas options and change button label
   */
  function gnuplotButn(btn,flag,toggleFunc,toggleArg) {  
    var btnLabel = btn.innerHTML.replace(/( On)|( Off)$/,'');	// Button label
    toggleFunc(toggleArg);		// Do gnuplot magic
    btn.innerHTML = btnLabel + (flag ? ' On' : ' Off');  	// Relabel
    btn.blur();				// Remove stupid focus border
  }					// --- gnuplotButn ---
  
</script>

<body onload="initPage(); dataLoopRun=0; switchDataLoop(0);">
  <!-- When resizing canvas, don't forget to set new size in Gnuplot "set term" 
       command in backend script. Canvas is nicely centered with <center> tag,
       "style" below is used just because CSS is "cool". To avoid middle and
       right clicks on the canvas being intercepted by the browser, we ignore
       "oncontextmenu" event. CSS element "pointer-events: none;" blocks any mouse
       interaction with the canvas and *restores default* mouse behavior.
       
       When the canvas gets resized don't forget to set size and offset of the
       crosshairs <div> - see note below.
       -->
  <canvas id="cs" width=800 height=600 oncontextmenu="return false;" 
          style="display: block; margin: auto; cursor: crosshair;">
    <div id="err_msg">No support for HTML 5 canvas element</div>
  </canvas>

  <!-- Crosshairs lines over above canvas (they are defined with 
       crossHairs.init("cs","hAxId","valid"); call) work great, but the lines are
       exactly of the canvas' size and are visible beyond plot area - this is 
       acceptable, but doesn't look great. To tackle the problem we add a separate 
       smaller <div> under the canvas and set it to the size and position of the plot.
       When the canvas gets initialized, plotSize.init() call adjusts <div> 
       position and size based on the current canvas coordinates, then
       crossHairs.init() call gets this <div> id and crosshairs are of the size and
       position of the plot area. However the <div> sits below the canvas, the 
       canvas intercepts all mouse events and the <div> does not see mouse 
       movements. When the <div> is placed above the canvas, it does not allow the
       canvas to get mouse events - crosshairs work great, but we cannot interact 
       with the plot.
       
       To solve the problem the canvas catches "mousemove" and "mouseleave" events
       and translates them to crosshairs <div> with plotSize.passEvent() function.
       This twist works well: the plot interacts with the mouse, crosshairs are
       right within plot area. Now the problem is, "mouseleave" event fires when
       mouse leaves the canvas (and not the smaller plot area) and crosshairs
       are still displayed outside the plot. This problem was solved by constantly
       checking mouse coordinates to see if they are within the plot area. 
       Once any coordinate leaves plot area, the crosshairs drawing program hides 
       crosshairs with crossHairs.hideCross(). See plotSize object code
       (above) for the source.
       
       When the canvas gets resized (this is implemented with plotSize.setW() and
       plotSize.setH() methods above) these methods call plotSize.adjustPLotArea()
       which sets size and offset of the crosshairs <div>. plotSize.adjustPLotArea()
       is also called when the canvas is initialized with plotSize.init(). The size 
       and offset of the crosshairs <div> relative to the canvas were obtained
       experimentally and (most likely) will get changed with new version of
       gnuplot utility.
  -->
  
  <div id="plotAreaId" style="width: 1px; height: 1px; z-index: -1;
			      position: absolute;
			      border: none; /* Uncomment below for debugging */
			      /* border: 1px dotted red; */"></div>
  
  <!-- Axis to display when mouse is over canvas. Vertical and horizontal ones -->    
  <div id="vAxId" style="width:1px; height: 1px; z-index: -1;
		         border-left: 1px dashed red; border-right: none; 
		         position: absolute;">
  </div>
  <div id="hAxId" style="width:1px; height: 1px; z-index: -1;
		         border-top: 1px dashed red; border-bottom: none; 
		         position: absolute;">
  </div>
  
  <center>
  <p><p>
  <!-- NOTE: Buttons with gnuplot_* ids below rely on gnuplot *internal* 
       variables and functions found in gnuplot_mouse.js file. This piece
       of code could be incompatible with future gnuplot releases!! -->
  <button id="gnuplot_grid_icon" title="Show or hide the grid"
   onClick="gnuplotButn(this,gnuplot.grid_lines,gnuplot.toggle_grid)">Grid Off</button>
  <button id="gnuplot_toggle_icon" title="Show or hide the plot"
   onClick="gnuplotButn(this,! gnuplot['hide_'+'cs_plot_1'],gnuplot.toggle_plot,'cs_plot_1')">Plot Off</button>
  <button id="gnuplot_textzoom_icon" title="Zoom static labels when zooming the plot"
   onClick="gnuplotButn(this,gnuplot.zoom_text,gnuplot.toggle_zoom_text)">L.Zoom On</button>
  <button id="gnuplot_rezoom_icon" title="Redisplay zoomed plot" 
   onClick="gnuplot.rezoom(); this.blur()">ReZoom</button>
  <button id="gnuplot_unzoom_icon" title="Switch zoom off"
   onClick="gnuplot.unzoom(); this.blur()">UnZoom</button>
  <!-- End of weak code -->
  <p><p>
  <nobr>
  Plot size:&nbsp;<input type="text" id="plotWId" value=""
  		   title="Plot area width"
  		   onKeypress="isEnterKey(event) && plotSize.setW(this.value);"
  		   onBlur="plotSize.setW(this.value);"
  		   size="4" maxlength="4">
  &times;
  <input type="text" id="plotHId" value=""
  		   title="Plot area heigth"
  		   onKeypress="isEnterKey(event) && plotSize.setH(this.value);"
  		   onBlur="plotSize.setH(this.value);"
  		   size="4" maxlength="4">&nbsp;px
  &nbsp;&nbsp;&nbsp;
  <span title="Delay between data acquiring cycles, msec">
  Refresh delay:&nbsp;<input type="text" id="refreshDelayId" value=""
  		       onKeypress="isEnterKey(event) && dataRefresh.set(this.value);"
  		       onBlur="dataRefresh.set(this.value);"
		       size="4" maxlength="5">&nbsp;msec
  </span>
  </nobr>
  <p><p>			<!-- DSO horiz. controls -->
  <span title="Oscilloscope channel to display">
  <span id="chanColorId"><B>Channel:</B>&nbsp;</span><select id="chanSelId"
		 onChange="dsoData.chanSet(this.value);">
<!--                 onChange="dsoData.shoCnColor('chanColorId',this.value);"> -->
      <option value="1" selected>&nbsp;1&nbsp;</option>
      <option value="2">&nbsp;2&nbsp;</option>
      <option value="3">&nbsp;3&nbsp;</option>
      <option value="4">&nbsp;4&nbsp;</option>
    </select>
  </span>&nbsp;&nbsp;&nbsp;
  <span title="Selected channel input coupling: &cong; - AC/DC or &asymp; - just AC">  
  Input:&nbsp;<select id="chanCoupId" 
	       onChange="dsoData.coupSet(this.value)"
	       onClick="dsoData.coupSet(this.value)">
    <option value="DC">&nbsp;&cong;&nbsp;</option>
    <option value="AC" selected>&nbsp;&asymp;&nbsp;</option>
    </select>
  </span>&nbsp;&nbsp;&nbsp;
  <span title="Plot starting position">
  Plot start:&nbsp;<select id="plotOrigSelId"
		    onChange="dsoData.timRefSet(this.value)"
		    onClick="dsoData.timRefSet(this.value)">
		    <option value="LEFT">Left</option>
		    <option value="CENT" selected>Center</option>
		    <option value="RIGH">Right</option>
		    </select>
  </span>&nbsp;&nbsp;&nbsp;
  <span title="Waveform points to read (:WAV:DATA? query)">
  Wave points:&nbsp;<select id="wavPointsId"
  		     onChange="dsoData.pointsSet(this.value);">
    <option value="100">100</option>
    <option value="250">250</option>
    <option value="500">500</option>
    <option value="1000">1000</option>
    <!-- Wave points options with more than 1000 points are not "stable": DSO
         silently and irrecoverably (until *RST) resets them to 1000 after 
         ":AUT ChanN" command (single ":AUT" does not reset!) and after 
         setting horiz.time(!!). Because of this these values are 
         (temporarily?) commented out.
    <option value="2000">2000</option>
    <option value="5000">5000</option>
    <option value="10000">10000</option>
    -->
    </select>
  </span>&nbsp;&nbsp;&nbsp;
  <span title="Horizontal time, used with :TIM:RANG">
  Time range:&nbsp;<input type="text" id="timRangeId" value=""
		    onKeypress="isEnterKey(event) && 
		      dsoData.timRangeSet(this.value,document.getElementById('timRangeSelId').value);"
		    onBlur="dsoData.timRangeSet(this.value,document.getElementById('timRangeSelId').value);"
		    size="3" maxlength="5"><select id="timRangeSelId"
		    	title="Horizontal time unit"
			onChange="dsoData.timRangeSet(document.getElementById('timRangeId').value,this.value)"
		        >
		    <option value="1E-9">nsec</option>
		    <option value="1E-6">usec</option>
		    <option value="1E-3">msec</option>
		    <option value="1">sec</option>
		    </select>
  </span>&nbsp;&nbsp;&nbsp;
  <span id="trigColorId" title="Channel that triggers the oscilloscope">
  <B>Trigger:</B>&nbsp;<select id="trigId"
                 onChange="dsoData.trigSet(this.value); dsoData.shoCnColor('trigColorId',this.value)"
                 onClick="dsoData.trigSet(this.value); dsoData.shoCnColor('trigColorId',this.value)">
                <option value="1" selected>Ch.1</option>
                <option value="2">Ch.2</option>
                <option value="3">Ch.3</option>
                <option value="4">Ch.4</option>
                <option value="E">Ext.</option>
                </select>
  </span>
  <p><p>
  <span title="Selected channel vertical range, Volts">
  Vert.range:&nbsp;<input id="chanRangId" type="text" value="" 
		    onKeypress="isEnterKey(event) &&
			        dsoData.vRangeSet(this.value,dsoData.chanSel.value);"
		    onBlur="dsoData.vRangeSet(this.value,dsoData.chanSel.value);"
		    size="6" maxlength="6">&nbsp;V
  </span>&nbsp;&nbsp;&nbsp;
  <span title="Selected channel vertical scale, Volts per division">
  Vert.scale:&nbsp;<input id="chanScalId"  type="text" value="" 
		    onKeypress="isEnterKey(event) &&
			        dsoData.vScaleSet(this.value,dsoData.chanSel.value);"
		    onBlur="dsoData.vScaleSet(this.value,dsoData.chanSel.value);"
		    size="6" maxlength="6">&nbsp;V/div
  </span>&nbsp;&nbsp;&nbsp;
  <span title="Data to plot source: imitator or real oscilloscope">
  Data source:&nbsp;<select id="dataSrcId" onChange="srcCtl.checkIP();">
    <option value="" selected>Imitator</option>
    <option value="dso">DSO6054L</option>
    </select>
  </span>&nbsp;&nbsp;&nbsp;
  <span title="Oscilloscope IP address">
  Instrument IP addr:&nbsp;<input id="dataIpId" type="text"
  			    size="15" maxlength="15"
  			    onKeypress="isEnterKey(event) && srcCtl.checkIP();"
			    onBlur="srcCtl.checkIP();">
  </span>
  <p><p>
  <button id="autoScId" title="Run autoscale (:AUT CHANn) command"
   onClick="runCmd('AutoS','cn',dsoData.chanSel.value,'val',dsoData.trig); dsoData.plotOrig.value='Center'; this.blur()">Autoscale</button>
  <!--button id="initInstId" onClick="runCmd('Init','cn',dsoData.chanSel.value,'timRang',dsoData.timRange); this.blur()">Init</button-->
  <button id="initInstId" title="Reset (*RST) the instrument"
   onClick="runCmd('Reset'); this.blur()">Reset</button>
  <button id="statReqId" title="Get instrument settings"
   onClick="runCmd('statReq'); this.blur()">Settings</button>
  <button id="stopDtLoopId" title="Run/Stop the instrument"
   onclick="switchDataLoop(0); this.blur()">Stop</button>
  <button id="singleDtLoopId" title="Run the instrument once (:SINGLE command)"
   onclick="switchDataLoop(1); this.blur()" disabled>Step</button>
  <p><p>
  <div id="statAreaId" 
   style="font-family: monospace; color: #EF0000; font-weight: bold;"></div>
  
  </center>
</body>
</html>
